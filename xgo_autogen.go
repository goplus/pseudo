// Code generated by xgo (XGo); DO NOT EDIT.

package main

import (
	"fmt"
	"github.com/goplus/xgo/tpl"
	"github.com/goplus/xgo/tpl/token"
	"github.com/goplus/xgo/tpl/types"
	_ "github.com/goplus/xgo/tpl/variant/builtin"
	"github.com/goplus/xgo/tpl/variant/delay"
	_ "github.com/goplus/xgo/tpl/variant/math"
	_ "github.com/goplus/xgo/tpl/variant/time"
	"github.com/qiniu/x/errors"
	"github.com/qiniu/x/stringutil"
	"os"
	"reflect"
	"strconv"
)

const _ = true

type pseudo struct {
	vars   map[string]interface{}
	consts map[string]interface{}
}
//line pseudo.gox:19:1
func (this *pseudo) exists(name string) bool {
//line pseudo.gox:20:1
	_, ok := this.vars[name]
//line pseudo.gox:21:1
	if !ok {
//line pseudo.gox:22:1
		_, ok = this.consts[name]
	}
//line pseudo.gox:24:1
	return ok
}
//line pseudo.gox:27:1
func (this *pseudo) value(name string) (v interface{}, ok bool) {
//line pseudo.gox:28:1
	v, ok = this.vars[name]
//line pseudo.gox:29:1
	if !ok {
//line pseudo.gox:30:1
		v, ok = this.consts[name]
	}
//line pseudo.gox:32:1
	return
}
//line pseudo.gox:35:1
func (this *pseudo) setValue(name string, v interface{}) {
//line pseudo.gox:36:1
	oldv, ok := this.vars[name]
//line pseudo.gox:37:1
	if !ok {
//line pseudo.gox:38:1
		panic(stringutil.Concat("variable ", name, " is undefined"))
	}
//line pseudo.gox:40:1
	if reflect.TypeOf(oldv) != reflect.TypeOf(v) {
//line pseudo.gox:41:1
		panic(stringutil.Concat("assignment of ", name, ": type mismatch"))
	}
//line pseudo.gox:43:1
	this.vars[name] = v
}
//line pseudo.gox:46:1
func (this *pseudo) chgValue(name string, chg func(oldv interface{}) interface{}) {
//line pseudo.gox:47:1
	oldv, ok := this.vars[name]
//line pseudo.gox:48:1
	if !ok {
//line pseudo.gox:49:1
		panic(stringutil.Concat("variable ", name, " is undefined"))
	}
//line pseudo.gox:51:1
	this.vars[name] = chg(oldv)
}
//line pseudo.gox:54
func (this *pseudo) Main() {
//line pseudo.gox:54:1
	if len(os.Args) < 2 {
//line pseudo.gox:55:1
		fmt.Println("Usage: pseudo <file>")
//line pseudo.gox:56:1
		return
	}
//line pseudo.gox:59:1
	this.vars = map[string]interface{}{}
//line pseudo.gox:60:1
	this.consts = map[string]interface{}{}
//line pseudo.gox:62:1
	cl := func() (_xgo_ret tpl.Compiler) {
//line pseudo.gox:62:1
		var _xgo_err error
//line pseudo.gox:62:1
		_xgo_ret, _xgo_err = tpl.NewEx(`

stmts = *stmtEOS => {
	return delay.stmtList(self)
}

stmtEOS = stmt ";" => {
	return self[0]
}

stmt = varStmt | constStmt | outputStmt | inputStmt | ifStmt | whileStmt | untilStmt | assignStmt

varStmt = "DECLARE" (IDENT % ",") ":" typeExpr => {
	namelist := self[1].([]any)
	typeVal := self[3]
	return delay.rangeOp(namelist, v => {
		t := v.(*tpl.Token)
		name := t.Lit
		if exists(name) {
			tpl.panic t.Pos, "${name} exists"
		}
		vars[name] = typeVal
	})
}

constStmt = "CONSTANT" IDENT "<-" expr => {
	t := self[1].(*tpl.Token)
	return delay.evalOp(self[3], v => {
		name := t.Lit
		if exists(name) {
			tpl.panic t.Pos, "${name} exists"
		}
		consts[name] = v
	})
}

assignStmt = IDENT "<-" expr => {
	t := self[0].(*tpl.Token)
	return delay.setValue(t.Lit, setValue, self[2])
}

inputStmt = "INPUT" IDENT => {
	t := self[1].(*tpl.Token)
	return delay.chgValue(t.Lit, chgValue, oldv => {
		v := reflect.new(type(oldv))
		fmt.scanln(v.Interface())!
		return v.elem.Interface()
	})
}

outputStmt = "OUTPUT" (expr % ",") => {
	exprlist := self[1].([]any)
	return delay.list(exprlist, vals => {
		echo vals...
	})
}

ifStmt = "IF" expr "THEN" ";" stmts ?("ELSE" ";" stmts) "ENDIF" => {
	return delay.ifElse(self[1], self[4], self[5], 2)
}

whileStmt = "WHILE" expr "DO" ";" stmts "ENDWHILE" => {
	return delay.while(self[1], self[4])
}

untilStmt = "REPEAT" ";" stmts "UNTIL" expr => {
	return delay.repeatUntil(self[2], self[4])
}

typeExpr = integer | real | string | boolean

integer = "INTEGER" => {
	return 0
}

real = "REAL" => {
	return 0.0
}

string = "STRING" => {
	return ""
}

boolean = "BOOLEAN" => {
	return false
}

expr = cmpExpr % and % or => {
	return tpl.binaryOp(true, self, (op, x, y) => {
		return delay.logicOp(op.Tok, x, y)
	})
}

and = "AND" => {
	return &tpl.Token{Tok: token.LAND}
}

or = "OR" => {
	return &tpl.Token{Tok: token.LOR}
}

cmpExpr = mathExpr % ("<" | "<=" | ">" | ">=" | "=" | "<>") => {
	return tpl.binaryOp(false, self, (op, x, y) => {
		return delay.compare(op.Tok, x, y)
	})
}

mathExpr = operand % ("*" | "/" | "%") % ("+" | "-") => {
	return tpl.binaryOp(true, self, (op, x, y) => {
		return delay.mathOp(op.Tok, x, y)
	})
}

operand = basicLit | parenExpr | unaryExpr | identOrCall

identOrCall = IDENT ?("(" ?(expr % ",") ")") => {
	t := self[0].(*tpl.Token)
	if params := self[1]; params != nil {
		return delay.call(true, t.Lit, params.([]any)[1])
	}
	return delay.valueOf(t.Lit, value)
}

parenExpr = "(" expr ")" => {
	return self[1]
}

unaryExpr = ("-" | "+" | "!") operand => {
	op := self[0].(*tpl.Token)
	return delay.unaryOp(op.Tok, self[1])
}

basicLit = intVal | floatVal | stringVal | true | false

true = "true" => {
	return true
}

false = "false" => {
	return false
}

stringVal = STRING => {
	return self.(*tpl.Token).Lit.unquote!
}

floatVal = FLOAT => {
	return self.(*tpl.Token).Lit.float!
}

intVal = INT => {
	return self.(*tpl.Token).Lit.int!
}
`, "pseudo.gox", 62, 10, "stmts", func(self []interface{}) interface{} {
//line pseudo.gox:65:1
			return delay.StmtList(self)
		}, "stmtEOS", func(self []interface{}) interface{} {
//line pseudo.gox:69:1
			return self[0]
		}, "varStmt", func(self []interface{}) interface{} {
//line pseudo.gox:75:1
			namelist := self[1].([]interface{})
//line pseudo.gox:76:1
			typeVal := self[3]
//line pseudo.gox:77:1
			return delay.RangeOp(namelist, func(v any) {
//line pseudo.gox:78:1
				t := v.(*types.Token)
//line pseudo.gox:79:1
				name := t.Lit
//line pseudo.gox:80:1
				if this.exists(name) {
//line pseudo.gox:81:1
					tpl.Panic(t.Pos, stringutil.Concat(name, " exists"))
				}
//line pseudo.gox:83:1
				this.vars[name] = typeVal
			})
		}, "constStmt", func(self []interface{}) interface{} {
//line pseudo.gox:88:1
			t := self[1].(*types.Token)
//line pseudo.gox:89:1
			return delay.EvalOp(self[3], func(v any) {
//line pseudo.gox:90:1
				name := t.Lit
//line pseudo.gox:91:1
				if this.exists(name) {
//line pseudo.gox:92:1
					tpl.Panic(t.Pos, stringutil.Concat(name, " exists"))
				}
//line pseudo.gox:94:1
				this.consts[name] = v
			})
		}, "assignStmt", func(self []interface{}) interface{} {
//line pseudo.gox:99:1
			t := self[0].(*types.Token)
//line pseudo.gox:100:1
			return delay.SetValue(t.Lit, this.setValue, self[2])
		}, "inputStmt", func(self []interface{}) interface{} {
//line pseudo.gox:104:1
			t := self[1].(*types.Token)
//line pseudo.gox:105:1
			return delay.ChgValue(t.Lit, this.chgValue, func(oldv any) any {
//line pseudo.gox:106:1
				v := reflect.New(reflect.TypeOf(oldv))
//line pseudo.gox:107:1
				func() (_xgo_ret int) {
//line pseudo.gox:107:1
					var _xgo_err error
//line pseudo.gox:107:1
					_xgo_ret, _xgo_err = fmt.Scanln(v.Interface())
//line pseudo.gox:107:1
					if _xgo_err != nil {
//line pseudo.gox:107:1
						_xgo_err = errors.NewFrame(_xgo_err, "fmt.scanln(v.Interface())", "pseudo.gox", 107, "main.Main")
//line pseudo.gox:107:1
						panic(_xgo_err)
					}
//line pseudo.gox:107:1
					return
				}()
//line pseudo.gox:108:1
				return v.Elem().Interface()
			})
		}, "outputStmt", func(self []interface{}) interface{} {
//line pseudo.gox:113:1
			exprlist := self[1].([]interface{})
//line pseudo.gox:114:1
			return delay.List(exprlist, func(vals []any) {
//line pseudo.gox:115:1
				fmt.Println(vals...)
			})
		}, "ifStmt", func(self []interface{}) interface{} {
//line pseudo.gox:120:1
			return delay.IfElse(self[1], self[4], self[5], 2)
		}, "whileStmt", func(self []interface{}) interface{} {
//line pseudo.gox:124:1
			return delay.While(self[1], self[4])
		}, "untilStmt", func(self []interface{}) interface{} {
//line pseudo.gox:128:1
			return delay.RepeatUntil(self[2], self[4])
		}, "integer", func(self interface{}) interface{} {
//line pseudo.gox:134:1
			return 0
		}, "real", func(self interface{}) interface{} {
//line pseudo.gox:138:1
			return 0.0
		}, "string", func(self interface{}) interface{} {
//line pseudo.gox:142:1
			return ""
		}, "boolean", func(self interface{}) interface{} {
//line pseudo.gox:146:1
			return false
		}, "expr", func(self []interface{}) interface{} {
//line pseudo.gox:150:1
			return tpl.BinaryOp(true, self, func(op *types.Token, x any, y any) any {
//line pseudo.gox:151:1
				return delay.LogicOp(op.Tok, x, y)
			})
		}, "and", func(self interface{}) interface{} {
//line pseudo.gox:156:1
			return &types.Token{Tok: token.LAND}
		}, "or", func(self interface{}) interface{} {
//line pseudo.gox:160:1
			return &types.Token{Tok: token.LOR}
		}, "cmpExpr", func(self []interface{}) interface{} {
//line pseudo.gox:164:1
			return tpl.BinaryOp(false, self, func(op *types.Token, x any, y any) any {
//line pseudo.gox:165:1
				return delay.Compare(op.Tok, x, y)
			})
		}, "mathExpr", func(self []interface{}) interface{} {
//line pseudo.gox:170:1
			return tpl.BinaryOp(true, self, func(op *types.Token, x any, y any) any {
//line pseudo.gox:171:1
				return delay.MathOp(op.Tok, x, y)
			})
		}, "identOrCall", func(self []interface{}) interface{} {
//line pseudo.gox:178:1
			t := self[0].(*types.Token)
//line pseudo.gox:179:1
			if
//line pseudo.gox:179:1
			params := self[1]; params != nil {
//line pseudo.gox:180:1
				return delay.Call(true, t.Lit, params.([]interface{})[1])
			}
//line pseudo.gox:182:1
			return delay.ValueOf(t.Lit, this.value)
		}, "parenExpr", func(self []interface{}) interface{} {
//line pseudo.gox:186:1
			return self[1]
		}, "unaryExpr", func(self []interface{}) interface{} {
//line pseudo.gox:190:1
			op := self[0].(*types.Token)
//line pseudo.gox:191:1
			return delay.UnaryOp(op.Tok, self[1])
		}, "true", func(self interface{}) interface{} {
//line pseudo.gox:197:1
			return true
		}, "false", func(self interface{}) interface{} {
//line pseudo.gox:201:1
			return false
		}, "stringVal", func(self interface{}) interface{} {
//line pseudo.gox:205:1
			return func() (_xgo_ret string) {
//line pseudo.gox:205:1
				var _xgo_err error
//line pseudo.gox:205:1
				_xgo_ret, _xgo_err = strconv.Unquote(self.(*types.Token).Lit)
//line pseudo.gox:205:1
				if _xgo_err != nil {
//line pseudo.gox:205:1
					_xgo_err = errors.NewFrame(_xgo_err, "self.(*tpl.Token).Lit.unquote", "pseudo.gox", 205, "main.Main")
//line pseudo.gox:205:1
					panic(_xgo_err)
				}
//line pseudo.gox:205:1
				return
			}()
		}, "floatVal", func(self interface{}) interface{} {
//line pseudo.gox:209:1
			return func() (_xgo_ret float64) {
//line pseudo.gox:209:1
				var _xgo_err error
//line pseudo.gox:209:1
				_xgo_ret, _xgo_err = strconv.ParseFloat(self.(*types.Token).Lit, 64)
//line pseudo.gox:209:1
				if _xgo_err != nil {
//line pseudo.gox:209:1
					_xgo_err = errors.NewFrame(_xgo_err, "self.(*tpl.Token).Lit.float", "pseudo.gox", 209, "main.Main")
//line pseudo.gox:209:1
					panic(_xgo_err)
				}
//line pseudo.gox:209:1
				return
			}()
		}, "intVal", func(self interface{}) interface{} {
//line pseudo.gox:213:1
			return func() (_xgo_ret int) {
//line pseudo.gox:213:1
				var _xgo_err error
//line pseudo.gox:213:1
				_xgo_ret, _xgo_err = strconv.Atoi(self.(*types.Token).Lit)
//line pseudo.gox:213:1
				if _xgo_err != nil {
//line pseudo.gox:213:1
					_xgo_err = errors.NewFrame(_xgo_err, "self.(*tpl.Token).Lit.int", "pseudo.gox", 213, "main.Main")
//line pseudo.gox:213:1
					panic(_xgo_err)
				}
//line pseudo.gox:213:1
				return
			}()
		})
//line pseudo.gox:62:1
		if _xgo_err != nil {
//line pseudo.gox:62:1
			_xgo_err = errors.NewFrame(_xgo_err, "tpl`\n\nstmts = *stmtEOS => {\n\treturn delay.stmtList(self)\n}\n\nstmtEOS = stmt \";\" => {\n\treturn self[0]\n}\n\nstmt = varStmt | constStmt | outputStmt | inputStmt | ifStmt | whileStmt | untilStmt | assignStmt\n\nvarStmt = \"DECLARE\" (IDENT % \",\") \":\" typeExpr => {\n\tnamelist := self[1].([]any)\n\ttypeVal := self[3]\n\treturn delay.rangeOp(namelist, v => {\n\t\tt := v.(*tpl.Token)\n\t\tname := t.Lit\n\t\tif exists(name) {\n\t\t\ttpl.panic t.Pos, \"${name} exists\"\n\t\t}\n\t\tvars[name] = typeVal\n\t})\n}\n\nconstStmt = \"CONSTANT\" IDENT \"<-\" expr => {\n\tt := self[1].(*tpl.Token)\n\treturn delay.evalOp(self[3], v => {\n\t\tname := t.Lit\n\t\tif exists(name) {\n\t\t\ttpl.panic t.Pos, \"${name} exists\"\n\t\t}\n\t\tconsts[name] = v\n\t})\n}\n\nassignStmt = IDENT \"<-\" expr => {\n\tt := self[0].(*tpl.Token)\n\treturn delay.setValue(t.Lit, setValue, self[2])\n}\n\ninputStmt = \"INPUT\" IDENT => {\n\tt := self[1].(*tpl.Token)\n\treturn delay.chgValue(t.Lit, chgValue, oldv => {\n\t\tv := reflect.new(type(oldv))\n\t\tfmt.scanln(v.Interface())!\n\t\treturn v.elem.Interface()\n\t})\n}\n\noutputStmt = \"OUTPUT\" (expr % \",\") => {\n\texprlist := self[1].([]any)\n\treturn delay.list(exprlist, vals => {\n\t\techo vals...\n\t})\n}\n\nifStmt = \"IF\" expr \"THEN\" \";\" stmts ?(\"ELSE\" \";\" stmts) \"ENDIF\" => {\n\treturn delay.ifElse(self[1], self[4], self[5], 2)\n}\n\nwhileStmt = \"WHILE\" expr \"DO\" \";\" stmts \"ENDWHILE\" => {\n\treturn delay.while(self[1], self[4])\n}\n\nuntilStmt = \"REPEAT\" \";\" stmts \"UNTIL\" expr => {\n\treturn delay.repeatUntil(self[2], self[4])\n}\n\ntypeExpr = integer | real | string | boolean\n\ninteger = \"INTEGER\" => {\n\treturn 0\n}\n\nreal = \"REAL\" => {\n\treturn 0.0\n}\n\nstring = \"STRING\" => {\n\treturn \"\"\n}\n\nboolean = \"BOOLEAN\" => {\n\treturn false\n}\n\nexpr = cmpExpr % and % or => {\n\treturn tpl.binaryOp(true, self, (op, x, y) => {\n\t\treturn delay.logicOp(op.Tok, x, y)\n\t})\n}\n\nand = \"AND\" => {\n\treturn &tpl.Token{Tok: token.LAND}\n}\n\nor = \"OR\" => {\n\treturn &tpl.Token{Tok: token.LOR}\n}\n\ncmpExpr = mathExpr % (\"<\" | \"<=\" | \">\" | \">=\" | \"=\" | \"<>\") => {\n\treturn tpl.binaryOp(false, self, (op, x, y) => {\n\t\treturn delay.compare(op.Tok, x, y)\n\t})\n}\n\nmathExpr = operand % (\"*\" | \"/\" | \"%\") % (\"+\" | \"-\") => {\n\treturn tpl.binaryOp(true, self, (op, x, y) => {\n\t\treturn delay.mathOp(op.Tok, x, y)\n\t})\n}\n\noperand = basicLit | parenExpr | unaryExpr | identOrCall\n\nidentOrCall = IDENT ?(\"(\" ?(expr % \",\") \")\") => {\n\tt := self[0].(*tpl.Token)\n\tif params := self[1]; params != nil {\n\t\treturn delay.call(true, t.Lit, params.([]any)[1])\n\t}\n\treturn delay.valueOf(t.Lit, value)\n}\n\nparenExpr = \"(\" expr \")\" => {\n\treturn self[1]\n}\n\nunaryExpr = (\"-\" | \"+\" | \"!\") operand => {\n\top := self[0].(*tpl.Token)\n\treturn delay.unaryOp(op.Tok, self[1])\n}\n\nbasicLit = intVal | floatVal | stringVal | true | false\n\ntrue = \"true\" => {\n\treturn true\n}\n\nfalse = \"false\" => {\n\treturn false\n}\n\nstringVal = STRING => {\n\treturn self.(*tpl.Token).Lit.unquote!\n}\n\nfloatVal = FLOAT => {\n\treturn self.(*tpl.Token).Lit.float!\n}\n\nintVal = INT => {\n\treturn self.(*tpl.Token).Lit.int!\n}\n`", "pseudo.gox", 62, "main.Main")
//line pseudo.gox:62:1
			panic(_xgo_err)
		}
//line pseudo.gox:62:1
		return
	}()
//line pseudo.gox:217:1
	delay.InitUniverse("builtin", "math", "time")
//line pseudo.gox:219:1
	e, err := cl.Parse(os.Args[1], nil, nil)
//line pseudo.gox:220:1
	if err != nil {
//line pseudo.gox:221:1
		fmt.Fprintln(os.Stderr, err)
	} else {
//line pseudo.gox:223:1
		delay.Eval(e)
	}
}
func main() {
	new(pseudo).Main()
}
